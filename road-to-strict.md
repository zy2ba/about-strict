# Миграция кодовой базы на strict mode family options для чайников

## Слайд 1

1. Честно говоря мне немного неловко в 2021 году поднимать тему перехода на строгие проверки типов в таком typescript-frendly сообществе, как angular framework.

## Слайд 2

1. Для меня видится очевидным, что новые проекты сейчас - это обязательно typscript c strict:true, а так же
   fullTemplateTypeCheck для angular проектов без Ivy. И strictTemplates, возможно с некоторыми исключениями, для проектов где Ivy уже есть.
2. Однако нам всё ещё приходится работать с уже существующей кодовой базой и развивать её. У того кто её начинал могли быть другие стандарты прекрасного. Даже если это были вы. Стоит всё же попытаться перейти на строгую проверку типипов.
3. Этот доклад ещё раз напомнит о том какие конкретно требования будут предъявляться к вашему коду при повышении строгости. А так же даст набор рекомендаций по тому как их исполнить с преемлемым уровнем страданий.

## Слайд 3

Прежде чем перейти к сухому коду вспомним что же нам даёт повышение строгости проверок.

Они заставляют нас более корректно и однозначно описывать структуры данных и соблюдать объявленные протоколы.

## Слайд 4

Angular и TS начинают ругаться на более широкий круг JS-like вольностей, загоняя нас в рамки.

Для большой и долгоживущей кодовой базы сие является благом.

## Слайд 5

1. Итак - у вас есть кодовая база с неоправдано либеральными настройками и вы решились на то, чтоб закрутить гайки.

2. Первым делом стоит повышать строгость Typescript Compiler. Самый простой способ это сделать - это переключить насткойку компилятора strict в значение true.

## Слайд 6

1. Что же за ней кроется?
2. Включив strict режим мы включили сразу 7 различных проверок.
3. Можно конечно включать их по отдельности
4. Так же можно отключить некоторые из них уже после включения strict:true, если, например, вдруг поняли что не справляетесь
5. Но безусловно лучше оставить включеными их всех

## Слайд 7 - бесплатная часть

Тут я хочу вас немного порадовать. Есть несколько проверок, котором ваш Angular код с огромной долей вероятности уже соотвтествует.

## Слайд 8

1.  alwaysStrict (2.1)
1.  аналогичен написанию “use strict” для всего когда
1.  учитывая что мы говорим про anguar, то было бы странно если бы мы писали не на классах. А для классов расширенный режим не предусмотрен by design, так что код который сломается по этому пункту встретиться не должен

## Слайд 9

1.  noImplicitAny
1.  смею предположить, что у большинства из вас подобный запрет из покон веков действует на уровне линтера, так что пожалуй данный переключатель так же можно считать условно бесплатным
1.  отключает подразумевание any как типа "по умолчанию", то есть убирает негласное объяевление небезопасного типа
1.  если ты собрался объявить что-то как any, то должен указать это явно, возможно тебе станет стыдно и ты допишешь более безопасный тайпинг

1.  any - это очень-очень плохо, но что делать если тип неизвестен, а помимо этого ещё и неважен?
1.  например достаточно проверить на Falsy/Truly
1.  используйте unknown - любой тип удовлетворяет unknown, но без явного описания каста к чему-либо не получится отуда что-то достать

## Слайд 10 - Улучшаем выведение типов

1. Эти флаги повысят качество выведения типов в typescript.

1. честно говоря по поводу некоторых из них у меня есть вопросы относительно того - а почему это надо дополнительно включать?

## Слайд 11 - noImplicitThis

1.  noImplicitThis (2.0)

1.  Если функция определена вне объекта/класса, то TS попросит явно указать на что будет ссылаться “this” используя для этого конструкцию с первым псевдо-аргументом с именем “this”. Это позволит избежать ситуаций когда this берётся как any

```
function getName(name: string): string {
    return this ? name: 'no context';
}
```

```
function getName(this: ContextObjectModel, name: string): string {
    return this ? name: 'no context';
}
```

## Слайд 12 strictBindCallApply

1. Включает проверку типов контекста и аргуметов для функций bind, call и apply

1. На слайде представлен пример безобразия которое будет проигнорировано компилятором typescript при отключении данного флага

1. Не уверен в том насколько они часто оказываются нужны в рамках angular разработки, но если понадобятся - хочется быть уверенным, что протоколы будут соблюдены.

## Слайд 13 - Уменьшаем недосказанность

1. Эти флаги отберут у вас возможность подразумевать возможность иметь типы undefined и null как сами собой разумеющиеся. 
1. Пожалуй именно этот раздел заставит вас проделать самый большой объём работы.
1. Однако усилия по отказу от этой сладкой возможности - не плодить многочисленные заявления null undefined могут вскрыть существующие проблемы в коде.
   
## Слайд 14 - про конвенции

1. Одновременно с тем что они проще всего объясняются - это источник боли, но для того чтоб понять что делать с этой болью стоит придерживаться следующих конвенций:
1. Использование undefined именно как значения - практически всегда неоправдано. Для undefied оставить именно роль только не переданного аргумента
  1. для объектных типов в качестве значения "отсутствия значения" горяздо лучше использовать null
  1. для number полей в качестве отсутствующего значения лучше испольщовать NaN

## Слайд 15 - strictFunctionTypes

1. Убирает бивариантную проверку для аргументов

1. до этого функция принимающая потомка заявленого типа аргумента удовлетворяла интерфейсу
1. теперь


## Слайд 16 - Проверки типов в шаблонах Angular
## Слайд 17 - RTFM
## Слайд 18 - Сужение типов
## Слайд 19 - Ещё пара моментов
